# 第一章 万丈高楼平地起
## Redis基础数据结构
### string(字符串)
- redis中的字符串通过唯一的key值来获取相应的value数据， key --> "Hello World"
- Redis中的字符串，采用`预分配冗余`的方式来减少内存分配。当字符串长度小于1M时，扩容都是加倍现有空间，如果超过1M,扩容时一次只会多扩1M的空间，字符串的最大长度时512M。
- 字符串由多个bit组成，这样便可以看作是bitmap[位图]
### list(列表)
- 是双向链表
- 在list中弹出最后一个元素，该数据结构自动被删除
- Redis中列表结构常常用来做异步队列(所以需要加锁互斥？)。将需要延后处理的任务结构体序列化称字符串，塞进Redis列表中，另一个线程从这个列表中`轮询`数据进行处理
#### 慢操作
- `lindex`获取链表index位置的元素值。类似的操作都是O(n)
#### quicklist
- 列表底层实现是一种称为`quicklist`的结构。在列表元素较少的时候，使用的是一块连续的内存存储，是`ziplist(压缩列表)`。`quicklist`是`ziplist`与`链表`的组合,也就是将多个`ziplist`用双向指针串起来使用
### hash(字典)
- hash可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash可以对用户结构中的每个字段单独存储，这样当我们需要获取用户信息时可以进行部分获取，而以整个字符串的形式去保存用户信息的化就只能一次性全部读取，这样比较浪费网络流量。hash的`缺点`是hash结构的存储消耗要高于单个字符串
- hash的内部结构？
### set(集合)
- 内部实现相当于一个特殊的hash(字典)，也就是所有的value都是一个值NULL
- set可以用来存储活动中奖用户ID，因为有去重功能，可以保证一个用户不会中奖两次
#### (zset)有序列表
- 使用`跳表`实现具有权重的set，也即每一个元素都不一致，但是可以基于权重实现了排序。比如可以用来存储粉丝列表，value值是粉丝用户ID，score是关注时间，我们可以对粉丝列表按关注时间排序
#### 跳表
#### 容器数据结构的通用规则
- list/set/hash/zse通用规则
    - `create if not exists`,也即不存在就创建它
    - `drop if no elements`,如果容器没有元素了，就删除元素，释放内存
- 所有数据结构都可以设置过期时间
## 第二章 分布式锁
### 分布式锁
- `setnx`(set if not exists)指令加锁，`del`指令释放锁。
    - 但是如果加锁之后，执行流程出错，之后不会释放锁了，所以可以使用`expire`来设置锁的过期时间
    - 但是在`setnx`与`expire`之间服务器进程挂了，这时也会死锁，那么，redis2.8引入了`set lock true ex 5 nx OK`，setnx与expire合并的原子指令
### 超时问题
- Redis分布式锁不要用于较长时间的任务，使用lua脚本来保证多个连续指令的原子性执行
### 可重入性
- `可重入性`是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。
- Redis分布式锁一般需要对set方法进行包装，使用线程Threadlocal变量存储当前持有锁的计数 
## 第三章 延时队列
### 异步消息队列
- Redis一般使用list(列表)来作为异步消息队列使用
### 队列空了怎么办
- 如果队列空了，客户端就会陷入pop的死循环，不停的pop，没有数据，接着再pop，没有数据，这就是空轮询
- 通常使用`sleep`来解决这个问题，让线程睡一会?
### 队列延迟
- `blpop/brpop`，b表示blocking，阻塞读，阻塞读再队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来，消息延迟几乎为零。
### 空闲连接自动断开
- 如果线程一直阻塞，Redis客户端连接就成了闲置连接，闲置过久，服务器就会主动断开连接，减少闲置支援占用，这个时候`blpop/brpop`会抛出异常。所以编写客户端消费者时，需要捕获异常，还要重试
### 锁冲突处理
- 一般有三种策略来处理客户端再请求加锁失败的情况：
    - 直接抛出异常，通知用户稍后重试
    - sleep 一会再重试
    - 将请求转移至延时队列，过会重试
### 延时队列的实现
- 使用zset(有序列表)来实现。将消息序列化成一个字符串作为zset的`value`,消息到期处理时间作为`score`
## 第四章 位图
- `零存`是指使用setbit对位值逐个设置，`整取`就是使用字符串一次性填充所有位数组
### 统计和查找
- `bitcount`来统计指定位置范围内1的个数，比如我们可以通过bitcount来统计用户一共签到了多少天，通过bitpos指令查找用户哪一天开始第一次签到
- `bitpos`用来查找指定范围内出现第一个0或1
### bitfield
- 可以用来对指定位片段进行读写，最多只能处理64个连续的位，子指令有`get/set/incrby`
- `incrby`自增可能出现溢出
## 第五章 HyperLogLog
- `HyperLogLog`提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是0.81%，但是可以`去重`并且`存储大数据`
### 使用方法
- `pfadd`添加数据
- `pfconut`统计数据
- `pfmerge`用于合并多个pf计数值
- 每个pf数占据12k的存储空间
## 第六章 布隆过滤器
- `布隆过滤器`实现的是快速高效的查看一个set中某个元素存在与否，只有小小的误判机率。
- 当布隆过滤器说某个值存在时，这个值可能不存在；当他说某个值不存在时，那他就肯定不存在
- `布隆过滤器`的大致原理是，多个无偏hash函数(无偏是指能够把元素hash值算的均匀)，当add一个key时，用多个hash置位一个大型的位数组、
- 在数据库中，当用户查询某个row时，可以使用布隆过滤器首先过滤掉大量不存在的row请求，然后再去磁盘进行查询
## 第七章 简单限流
- `限流`主要用来控制用户行为，比如在UGC社区，用户的发帖，回复，点赞等行为都要严格受控，一般要严格限定某行为在规定时间允许次数，超过了那就是非法行为，对于非法行为，业务必须规定适当的惩处策略
- Redis限流就是限定用户的某个行为在指定行为里只能发生N次
- `简单限流`利用`zset`的排序机制，来限定一个滑动窗口
## 第八章 漏斗限流
- 漏斗的剩余空间代表着当前行为可以持续进行的数量，漏嘴的流水速率代表着系统允许该行为的最大频率
### redis-cell
- `redis-cell`是redis4.0提供的一个限流模块，使用了漏斗算法，并且提供了`原子`的限流指令
## 第九章 GeoHash
- 业界比较通用的地理位置距离排序算法是GeoHash算法,Redis也是用GeoHash算法。GeoHash算法将二维的经纬数据映射到一维的整数，这要所有的元素都将在挂在到一条线上，距离靠近的二维坐标映射到一维后的点之间距离也会很接近
- zset的value是元素的key?
- 在redis集群迁移时，如果但各国key的数据过大，集合从一个节点迁移到另一个节点，会对集群造成较大影响，在集群环境中单个key对应的数据量不因该超过1M，如果数据量过大需要对Geo数据进行拆分，按国家，按省拆分
## 第十章 Scan
- Scan
    - 复杂度也是O(n),但是它是通过游标分步进行的，不会阻塞线程
    - 提供limit参数(limit限制的是单词遍历的字典槽数数量)，可以控制每次返回结果的最大条数，limit只是一个hint，返回结果可多可少
    - 与`keys`一样，它也提供模式匹配功能
    - 服务器不需要为游标保存状态，游标唯一状态就是scan返回给客户端的游标整数
    - 返回结果可能会有重复，需要客户端去重复，这点非常重要
    - 遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
    - 单词返回的结果是空不意味着遍历结束，而要看返回的游标值是否为空
### scan遍历顺序
- scan遍历顺序采用了`高位进位加法`来遍历，之所以使用这样特殊的方式遍历，是考虑到了字典的扩容和缩容时避免槽位的遍历重复和遗漏，这样可以在`扩容时`，避免遗漏
### 字典扩容
- `a mod 8 = a & (8 - 1) = a & 7`,假设字典的数组长度由8位扩容到16位，那么3号槽位`011`将被rehash到3(0011)号槽与11(1011)号槽位,也就是说有一半的元素还是留在3号槽位
### 渐进式rehash
- redis在rehash的时候，会同时保留新旧数组，然后在定时任务中以及后续对hash的指令中渐渐地将旧数组中挂接的元素迁移到新数组上。这意味着要操作处于rehash中字典，需要同时访问新旧两个数据结构，如果在旧数据下面找不到元素，还需要去新数组下寻找
### 大key扫描
- 在业务开发时，尽量避免大key的产生
- `如何定位大key`，使用scan指令，对于每一个扫描出来的key，使用type获取key的类型，然后使用相应的数据结构的size或len方法来得到它的大小，redis官方提供了这样的扫描功能`redis-cli -h 127.0.0.1 -p 7001 --bigkeys`
## 第十一章 原理 线程IO模型
- `Redis`是一个单线程程序，Node.js和Nginx也是单线程
- 单线程Redis仍然很快，是因为其所有数据都在内存中，所有的运算都是内存级别的运算对于事件复杂度为O(n)的运算，需要谨慎使用，不小心就会使得Redis卡顿
- Redis使用事件轮询机制来处理多个客户端，比如select
### 非阻塞IO
- 非阻塞IO在套接字对象上提供了一个选项`Non_Blocking`，当这个选项打开时，读写方法不会阻塞，有了非阻塞IO意味着线程`读写IO时`可以不必阻塞，瞬间完成读写
### 事件轮询(多路复用)
- `指令队列`,Redis会为每个客户端都关联一个指令队列，客户端的指令通过队列来排队进行处理，先到先服务
- `响应队列`，Redis会为每个客户端套接字关联一个响应队列，
- `定时任务`，服务器处理要响应的IO事件外，还要处理其他事件，比如定时任务，如果线程阻塞在select系统调用上，那么Redis如何处理?Redis的定时任务会记录在一个称为`最小堆`的数据结构中，这个堆中，最快要执行的任务排在堆最上方，在每个循环周期，Redis都会将最小堆李面以及到点的任务立即进行处理，处理完毕后，将最开要执行的任务还需要的事件记录下来，这个事件就是select系统调用的`timeout时间`,Nginx和Node的事件处理原理也和Redis类似。
## 第十三章 原理 通信协议
- Redis作者认为数据库系统的瓶颈一般不在于网络流量，而在于数据库自身内部逻辑，所以Redis使用了`浪费流量`的文本协议
### RESP(Redis Seialization Protocol)
- `RESP`简单，易理解，易实现。Redis协议将传输的结构分为5钟最小单元类型，单元结束时统一加上回车换行符`\r\n`
    - 单行字符以`+`开头
    - 多行字符以`$`开头，后跟字符串长度
    - 整数值以`:`开头，后跟整数的字符串形式
    - 错误信息，以`-`开头
    - 数据以`*`开头，后跟数组长度
## 第十四章 持久化
- Redis有两种持久化方法
    - `AOF日志`，
        - 连续的增量备份
        - 记录的是`内存数据修改的指令记录文本`
        - AOF日志在长期的运行过程钟会变得无比庞大，数据库重启时需要加载AOF日志进行指令重放，之歌事件就会无比漫长，需要定时进行`AOF重写`，给AOF日志瘦身。重写就是：`开辟一个子进程，对于内存进行遍历转换成一系列Redis操作指令`
        - Redis会在收到客户端修改指令后，先进行参数校验，如果没问题，就立即将该指令文本存储到AOF日志中，也就是先存到磁盘，然后再执行指令，这样即使遇到突发宕机，已经存储到AOF日志的指令进行重放就可恢复
        - Redis会每隔1s执行一次`fsync`，可以确保aof日志文件在内存中的缓存即使刷盘(`内核会为每一个文件描述符在内存中分配一个内存缓存区`)
    - `快照(RDB, redis database)`，
        - 是一次性全量备份，
        - 内存数据的二进制序列化形式，存储非常紧凑
        - `文件IO`不能使用多路复用API，所以Redis使用OS的`多进程COW`来实现快照持久化。1.Redis首先调用fork产生一个子进程,2.每当父进程修改一个页面的数据时，会将被共享的页面赋值一份分离出来，然后对这个复制的页面进行修改，这时`子进程相应的页面是没有变化的`3.子进程的数据不会变化，所以其可以安心的将`数据持久化/序列化到磁盘`
### 运维
- Redis的持久化很耗时，一般Redis主节点是不会进行持久化操作的，持久化操作主要是在`从节点`中进行，从节点是备份节点，所以没有来自客户端的压力，它的OS资源往往比较丰富
### Redis4.0混合持久化
- `混合持久化`,Redis将rdb(快照)文件内容核增量的AOF日志文件存在一起，这里的AOF日志不再是全量日志，而是`持久化开始到持久化结束这段事件发生的增量AOF日志`
    - Redis重启时，可以先加载rdb内存，然后再重放增量AOF日志就可以完全替代之前AOF全量文件重复，效率大大提高
## 第十五章 管道(pipeline)
- 类似于http1.1中的管道，也类似于没有使用`Nagle`算法的TCP
- `管道`之所以高效，是因为连续的`write操作是根本没有耗时`,所以管道不是服务器特性，而是客户端改变了读写顺序带来的巨大性能提升
## 第十六章 事务
- Redis中的事务
    - `multi == begin`
    - `exec == commit`
        - 所有指令再执行`exec`之前，将指令缓存再服务器的一个`事务队列`中,Redis是一个单线程，它不用担心执行队列的时候被其他指令打搅，这样就可保证`原子性`
    - `discard != rollback`,mysql的rollback与redis的discard的区别在于discard只是结束本次事务，对于之前已经执行过的语句的影响不会消除，而rollback会消除之前已经执行过的语句的影响。
- Redis事务的`原子性`，只是满足了事务的`隔离性`
### Watch
- Watch是一种`乐观锁`。Watch会在事务开始之前盯住1个或多个关键遍历，当事务执行时，也就是服务器收到了exec指令要顺序执行缓存的事务队列时，Redis会检查关键变量自watch之后，是否被修改了(包括当前事务所在的客户端)。如果关键变量被人动过了，exec指令就会返回null回复告知客户端事务执行失败了，客户端一般会选择重试。
## 第十七章 PubSub
- 普通的`消息队列`不支持`多播机制`，`消息多播`是指允许生产者生产一次消息，中间件将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费。它是分布式系统常用的一种`解耦`方式，用于多个消费组的逻辑进行拆分
### PubSub(PublisherSubscriber发布者订阅者模式)
- Redis PubSub的生产者与消费者是不同的连接？
### 模式订阅
- `psubscribe codehole.*`订阅多个主题
### 消息结构
### PubSub的缺点
## 第十八章 小对象压缩
- Redis的所有对象都存储在`内存`中，非常容易导致内存不足
### 32bit vs 64bit
- 如果使用32bit来编译Redis，内部所有的数据结构所使用的指针空间会减少一半，如果使用Redis的内存不超过4G,那么可以使用32bit编译
### 小对象压缩存储(ziplist)
- ziplist中可以存储hash结构，也可以存储zset结构?它是`紧凑存储形式压缩存储`
- `intset`是一个`紧凑的整数数组结构`
- 如果set里存储的是字符串，那么`sadd`立即升级为hashtable结构
- 如果Redis内部管理的集合数据很小，它会使用`紧凑存储形式压缩存储`
### 内存回收机制
- `flashdb`可以清空所有key
- redis会重新使用那些尚未回收的空闲内存
### 内存分配算法
- Redis直接使用facebook的jemalloc
## 第十九章 主从同步
### CAP原理
- C-Consistent 一致性
- A-Availability 可用性
- P-Partition tolerance 分区容忍性
- `网络分区发生时`，一致性和可用性两难全
### 最终一致性
- Redis主从数据是`异步同步的`，所以分布式Redis系统并不满足`一致性`的要求。当客户端在Redis的主节点修改了数据之后，立即返回，即使在主从网络断开的情况下，主节点仍然可以对外提供服务，所以Redis满足可用性，Redis保证`最终一致性`，从节点会努力追赶主节点
### 主从同步
- Redis的同步支持`主从同步`和`从从同步`
### 增量同步
- 增量同步通过记录`修改指令`，并向从节点发生`修改指令`，但是存储`修改指令`的`环`容量有限，所以需要`快照同步`
### 快照同步
- 快照同步非常耗费资源，它首先需要在主库上进行一次bgsave，将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点，从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空
### 无盘复制
- 无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将接受到的内容存储到磁盘文件中，再进行一次性加载
### Wait指令
- Redis的复制是异步进行的，wait指令可以让异步复制变身同步复制，确保系统的强一致性(不严格)
- Redis的`高可用`离开了主从复制将无从进行
## 第二十章 Sentinel
- Redis Sentinel用来保证`高可用`，使得当`主节点宕机`时，自动切换主从
- Sentinel集群可以看作ZooKeeper集群，它是集群高可用的心脏，一般由3~5个节点组成，这样挂了个别节点集群还可以正常运转。它持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优从节点切换为主节点。
    - 客户端来连接集群时，会首先连接sentinel，通过sentinel来查询主节点的地址，然后再去连接主节点进行数据交互
    - 当主节点发送故障时，客户端会重新向sentinel要地址，sentinel会将最新的主节点地址告诉客户端。
### 消息丢失
### Sentinel 基本使用
- 标准流程是客户端通过sentinel发现主从节点的地址，然后通过这些地址建立相应的连接来进行数据存取操作
- sentinel默认端口是26379，通过sentinel对象的discover_xxx方法可以发现主从地址，主地址只有一个，从地址可以有多个
- 通过xxx_for方法可以从连接池拿出一个连接来使用，因为从地址有多个，redis客户端对从地址采用轮询的方案，也就是RoundRobin,`为啥redis客户端需要连接从地址？`
## 第二十一章 Codis
- Codis是一个代理中间件，它和Redis一样使用Redis协议对外提供服务，当客户向Codis发送指令时，Codis负责转发到后面的Redis实例来执行，并将结果在转回给客户端
### Codis分片原理
- Codis负责将特定的key转发到特定的Redis实例
    - Codis将所有的key默认划分成1024个槽位，它首先对客户端传过来的key进行crc32运算哈希值，在将hash后的整数值对1024这个整数进行取模得到一个余数，这个余数就是对应key的槽位，`每个槽位都会映射到多个Redis实例之一，Codis会在内存中维护槽位和Redis实例的映射关系`
### 不同Codis实例之间槽位关系如何同步
- 使用Zookeeper/etcd
### 扩容
### 自动均衡
- Codis会在系统比较空闲的时候，观察每个Redis实例对应的Slots数量，自动均衡系统
### Codis的代价
- 不支持事务，因为Codis中所有key分布在不同的Redis实例中，`rename`也不支持
- 为了支持扩容，单个key对应的value不应该过大
- Codis增加了中间Proxy，所以网络开销比单个Redis大
### Codis的有点
- Codis在设计上相比Redis Cluster官网集群方案要简单很多，因为它将分布式问题交给了第三方zk/etcd去负责，自己就省去了复杂的分布式一致性代码的编写工作
### MGET指令操作过程
- mget指令用于批量获取多个key的值，这些key可能会分布在多个Redis实例中。Codis的策略是将key按照所分配的实例打散分组，然后一次对每隔实例调用megt方法，最后汇总，返回给客户端
## 第二十二章 Cluster
- RedisCluster相比较于Codis，它是`去中心化的`，
    - RedisCluster将所有数据划分为16384的slots，相比于Codis的1024个槽位划分的更为精细，每隔节点负责其中一部分槽位，槽位的信息存储在每隔节点中，它不像Codis，它不需要另外的分布式存储(zookeeper/etcd)来存储节点槽位信息
    - 当客户端来连接集群时，它也会得到一份集群的槽位配置信息，这样当客户端要查找某个key时，可以直接定位到目标节点
## 第二十三章 Stream
- `Stream`是一个支持多播的可持久化的消息队列
    - 每个Stream都有唯一的名称，他就是Redis的key，在首次使用`xadd`指令追加消息时自动创建
    - 每个消费组的状态都是独立的，相互不受影响，也就是说同一份Stream内部消息会被每隔消费组都消费到
    - 同一个消费组可以挂接多个消费者，这些消费者之间时竞争关系，任意一个消费者读取了消息都会时游标往前移动
### 独立消费
- Redis设计了一个单独的消费指令`xread`,可以将Stream当初普通的消息队列(list)来使用，使用`xread`的时候，可以完全忽略消费组的存在
## 第二十四章 Info指令
- `Info指令`可以显示Redis内部一系列运行参数
## 第二十五章 再谈分布式锁
- 可以使用`Redlock`算法来使得在`集群环境`中主从交换的时候也可以实现安全
    - `Redlock`主要是采用`大多数机制`。加锁时，它会向过半节点发送`set(key, value, nx=True, ex=xxx)`指令，只要过半节点同意，那就认为加锁成功。释放锁时，需要向所有节点发送`del`指令
## 第二十六章 过期策略
### 过期key集合
- redis会将每个设置了过期时间key放到一个独立的字典中，以后会定时遍历这个字典来删除到期的key。还会使用`惰性策略`来删除过期的key。
    - `定时扫描策略`
## 第二十七章 LRU
- 当Redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁交换，这样Redis效率会大幅降低，所以需要限制Redis最大使用内存
### 近似LRU
- Redis使用一个近似lru算法，并使用`淘汰池`优化
## 第二十八章 懒惰删除
- `unlink`指令来时先`懒惰删除`
- `flushall`是懒惰版的`flushdb`
    - `flushall async`可以异步慢速清空数据库
### 异步队列
- 主线程会将key的内存回收操作包装成一个任务，塞进任务队列，后台线程会从这个异步队列中取数据，任务队列被主线程和异步线程同时操作，所以必须是一个`线程安全`的队列
### AOF sync也很慢
- `AOF sync`也有自己的懒惰删除，也有属于自己的任务队列 
## 第三十章 保护redis
- redis可以通过`rename`指令来讲某些危险的指令修改成特别的名称
## 第三十一章 redis安全通信
- Redis本身不支持SSL安全连接，不过有了SSL代理软件，我们就可以让通信数据透明地得到加密，`spiped`是一款SSL代理软件
### spiped原理
- 客户端和服务器各启动一个spiped进程
    - 客户端的spiped进程负责接受来自Redis Client发送过来的请求数据，加密后传送到右边的spiped进程。
    - 服务器将接受将收到的数据解密后，传递给Redis Server
    - 每一个spiped进程都会有一个监听端口(server socker)用来接收数据，同时还会作为一个客户端(socket client)将数据转发到目标地址
    - spiped进程需要成对出现，相互之间需要使用相同的共享`密钥来加密消息`
## 第三十二章 探索`字符串`内部结构
- Redis的字符串是一个`Simple Dynamic String`，也就是动态可修改字符串，一个结构体记载，有`长度`有`容量`
    - SDS结构使用了泛型T，也就是字符串比较短的时候，`len`和`capacity`使用`byte`和`short`来表示，Redis的极致优化
    - redis规定字符串长度不得超过`512MB`,创建字符串时`len`和`capacity`一样
    - 为了便于使用`glibc`中的字符串里函数，以及便于字符串的调试打印输出，所以SDS结构体中`content`字符串是以`\0`结尾的
### embstr vs raw
- Redis字符串有两种存储方式，在长度特别短时，使用`emb`形式存储，当长度超过`44`时，使用`raw`形式存储
### 扩容策略
- 字符串在小于1M之前，扩容采用加倍策略，也就是100%的冗余空间，当长度超过1M之后，为了避免冗余空间过大而导致浪费，每次扩容只会分配`1M`大小的冗余空间
## 第三十三章 探索`字典`内部
- 除了`hash`数据结构外，整个Redis数据库的所有key和value组成了一个全局字典，`还有带过期时间的key集合也是一个字典`
## 第三十四章 探索`压缩列表`内部
- Redis为了节约内存空间，zset和hash容器在元素个数少的时候，采用`压缩列表(ziplist)`进行存储,压缩列表是一块连续内存空间，元素之间挨着存储，没有任何冗余空隙